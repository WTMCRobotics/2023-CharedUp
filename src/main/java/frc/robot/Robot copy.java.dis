// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;


import java.text.DecimalFormat;
import java.util.HashMap;

import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.apriltag.AprilTag;
import edu.wpi.first.apriltag.AprilTagDetection;
import edu.wpi.first.apriltag.AprilTagDetector;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.cscore.CvSink;
import edu.wpi.first.cscore.CvSource;
import edu.wpi.first.cscore.UsbCamera;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
  private static final String kDefaultAuto = "Default";
  private static final String kCustomAuto = "My Auto";
  private String m_autoSelected;
  private final SendableChooser<String> m_chooser = new SendableChooser<>();

  private MotorController frontLeft;
  private MotorController frontRight;
  private MotorController backLeft;
  private MotorController backRight;
  private XboxController xboxController;
  private AprilTagDetector aprilDetector;
  private AprilTagDetection[]  allAprilTags;
  private Thread m_visionThread;
  private HashMap<Integer, Integer> aprilConfidence;
  private HashMap<Integer, Boolean> hasDetectedLastFrame;
  private DecimalFormat df = new DecimalFormat("#.##");

  private final double ALIGNMENT_MARGIAN = 12;//The margian that the center of an April tag can be, to be counted as centerd
  private final int CAMERA_WIDTH = 640; //Camera resolution Width
  private final int CAMERA_HEIGHT = 480; //Camera resolution Height

  /**
   * This function is run when the robot is first started up and should be used for any
   * initialization code.
   */
  @Override
  public void robotInit() {
    m_chooser.setDefaultOption("Default Auto", kDefaultAuto);
    m_chooser.addOption("My Auto", kCustomAuto);
    SmartDashboard.putData("Auto choices", m_chooser);
    /*frontLeft = new Talon(0); //Assuming the motors are talons, if not, switch to Spark
    frontRight = new Talon(1);
    backLeft = new Talon(2);
    backRight = new Talon(3);
    xboxController = new XboxController(0);*/


    //Why do this? I don't know, I just copied some math
    /*frontRight.setInverted(true);
    backRight.setInverted(true);*/

    SmartDashboard.putString("Testing_Thingy", "Working!");
    SmartDashboard.updateValues();

    System.out.println("sysout test");
    m_visionThread =
        new Thread(
            () -> {
              System.out.println("Thead started");
              // Get the UsbCamera from CameraServer
              UsbCamera camera = CameraServer.startAutomaticCapture();
            
              // Set the resolution
              camera.setResolution(CAMERA_WIDTH, CAMERA_HEIGHT);

              // Get a CvSink. This will capture Mats from the camera
              CvSink cvSink = CameraServer.getVideo();
              // Setup a CvSource. This will send images back to the Dashboard
              CvSource outputStream = CameraServer.putVideo("Rectangle", CAMERA_WIDTH, CAMERA_HEIGHT);

          

              // Mats are very memory expensive. Lets reuse this Mat.
              Mat mat = new Mat();
              Mat greyMat = new Mat();
              Scalar red = new Scalar(0, 0, 255);
              Scalar green = new Scalar(0, 255, 0);
              Scalar yellow = new Scalar(0, 255, 255);

              double halfCameraWidth = CAMERA_WIDTH / 2; //Avoids re-doing math

              aprilDetector = new AprilTagDetector();
              //aprilDetector.addFamily("tag16h5");
              aprilDetector.addFamily("tag16h5", 0);

              aprilConfidence = new HashMap<>();
              hasDetectedLastFrame = new HashMap<>();
              for (int i = 0; i < 29; i ++) {
                aprilConfidence.put(i, 0);
                hasDetectedLastFrame.put(i, false);
              }


              
              // This cannot be 'true'. The program will never exit if it is. This
              // lets the robot stop this thread when restarting robot code or
              // deploying.
              System.out.println("Intia ltest");
              while (!Thread.interrupted()) {
                // Tell the CvSink to grab a frame from the camera and put it
                // in the source mat.  If there is an error notify the output.
                if (cvSink.grabFrame(mat) == 0) {
                  // Send the output the error.
                  outputStream.notifyError(cvSink.getError());
                  // skip the rest of the current iteration
                  continue;
                }
                //System.out.println("Test 2");
                //aprilTag = aprilDetector.detect(mat)[0];
                Imgproc.cvtColor(mat, greyMat, Imgproc.COLOR_RGB2GRAY);

                allAprilTags = aprilDetector.detect(greyMat);
                if (allAprilTags == null)  {
                  SmartDashboard.putNumber("Detected April Tags", 0);
                  System.out.println("Detected yep, there are "+allAprilTags.length);
                } else
                  SmartDashboard.putNumber("Detected April Tags", allAprilTags.length);

                Imgproc.circle(mat, 
                new Point(0, 0),//Circle the center point
                8, red);

                Imgproc.line(mat, new Point(halfCameraWidth - ALIGNMENT_MARGIAN, 0), new Point(halfCameraWidth - ALIGNMENT_MARGIAN, CAMERA_HEIGHT), yellow);
                Imgproc.line(mat, new Point(halfCameraWidth + ALIGNMENT_MARGIAN, 0), new Point(halfCameraWidth + ALIGNMENT_MARGIAN, CAMERA_HEIGHT), yellow);
                // Put a rectangle Around the AprilTag
                for (AprilTagDetection loopAprilTag : allAprilTags) {
                  //System.out.println("There is an apriltag being looped!");
                  if (loopAprilTag != null) {

                    if (aprilConfidence.get(loopAprilTag.getId()) == 0) {//Low confidence
                      //System.out.println("AprilTag Detected! Confidence: LOW");

                      aprilConfidence.put(loopAprilTag.getId(), 1); //Saying that: last frame, the april tag was detected as Low confidence
                      hasDetectedLastFrame.put(loopAprilTag.getId(), true);//Saying that the detected april tag was actualy found this frame

                      drawAprilTagOutlines(mat, loopAprilTag, red); //Draws the box, center point, and text on camera display, look below for more info
                    } else if (aprilConfidence.get(loopAprilTag.getId()) == 1) {//Medium confidence
                      //System.out.println("AprilTag Detected! Confidence: MEDIUM");

                      aprilConfidence.put(loopAprilTag.getId(), 2); //Saying that: last frame, the april tag was detected as Medium confidence
                      hasDetectedLastFrame.put(loopAprilTag.getId(), true);//Saying that the detected april tag was actualy found this frame
                    
                      drawAprilTagOutlines(mat, loopAprilTag, yellow);//Draws the box, center point, and text on camera display, look below for more info
                    
                    } else if (aprilConfidence.get(loopAprilTag.getId()) > 1) {//High confidence
                      //System.out.println("AprilTag Detected! Confidence: HIGH");


                      aprilConfidence.put(loopAprilTag.getId(), 3); //Saying that: last frame, the april tag was detected as High confidence
                      hasDetectedLastFrame.put(loopAprilTag.getId(), true); //Saying that the detected april tag was actualy found this frame
                      Pose3d f = new Pose3d();
                      SmartDashboard.putString("April Tag "+loopAprilTag.getId(), //Adding the info to the SmartDashBoard
                      //new String[]{
                        //"Top Left Corner: "+loopAprilTag.getCornerX(0)+", "+loopAprilTag.getCornerY(0),
                        //"Top Right Corner: "+loopAprilTag.getCornerX(1)+", "+loopAprilTag.getCornerY(1),
                        //"Bottom Left Corner: "+loopAprilTag.getCornerX(2)+", "+loopAprilTag.getCornerY(2),
                        //"Bottom Right Corner: "+loopAprilTag.getCornerX(3)+", "+loopAprilTag.getCornerY(3),
                        "Center: "+df.format(loopAprilTag.getCenterX())+", "+df.format(loopAprilTag.getCenterY())+
                        " AprilTag ID: "+loopAprilTag.getId()
                        //}
                      );
                      if (SmartDashboard.isPersistent("April Tag "+loopAprilTag.getId()))
                        SmartDashboard.clearPersistent("April Tag "+loopAprilTag.getId());

                      drawAprilTagOutlines(mat, loopAprilTag, green);//Draws the box, center point, and text on camera display, look below for more info
                    }
                  }
                }

                for (int i = 0; i < 29; i ++) {
                  if (!hasDetectedLastFrame.get(i)) //If the loop april tag was not detected in the last frame
                    if (aprilConfidence.get(i) > 1) { //Checking if it has a confidence value
                      aprilConfidence.put(i, (aprilConfidence.get(i) - 1)); //If it was, lower the confidence, as it wasn't detected this frame
                      if (aprilConfidence.get(i) < 1) //Checking if it has any confidence left
                        SmartDashboard.putString("April Tag "+i, null); //If not, remove it from the dashboard, as it's probably not in view anymore
                      }
                  hasDetectedLastFrame.put(i, false);//Reset the hasDetected
                }

                outputStream.putFrame(mat); // Give the output stream a new image to display
                SmartDashboard.updateValues();
              }
            });

    m_visionThread.setDaemon(true);
    m_visionThread.start();
  }

  private void drawAprilTagOutlines(Mat mat, AprilTagDetection tag, Scalar color) {

    /*Imgproc.rectangle( //Draw the rectangle outlining the enture AprilTag
      mat, new Point(tag.getCornerX(1), tag.getCornerY(1)),
      new Point(tag.getCornerX(3), tag.getCornerX(3)), color,
      5);*/

      SmartDashboard.putString("Tag "+tag.getId()+" Line Length 1", df.format(Math.sqrt( Math.pow((tag.getCornerX(3) - tag.getCornerX(0)), 2) + Math.pow((tag.getCornerY(3) - tag.getCornerY(0)), 2))));
      SmartDashboard.putString("Tag "+tag.getId()+" Line Length 2", df.format(Math.sqrt( Math.pow((tag.getCornerX(1) - tag.getCornerX(2)), 2) + Math.pow((tag.getCornerY(1) - tag.getCornerY(2)), 2))));

      Imgproc.line(mat, 
      new Point(tag.getCornerX(0), tag.getCornerY(0)), 
      new Point(tag.getCornerX(1), tag.getCornerY(1))
      , color, 5);
      Imgproc.line(mat, 
      new Point(tag.getCornerX(1), tag.getCornerY(1)), 
      new Point(tag.getCornerX(2), tag.getCornerY(2))
      , new Scalar(255, 255, 255), 5);
      Imgproc.line(mat, 
      new Point(tag.getCornerX(2), tag.getCornerY(2)), 
      new Point(tag.getCornerX(3), tag.getCornerY(3))
      , color, 5);
      Imgproc.line(mat, 
      new Point(tag.getCornerX(3), tag.getCornerY(3)), 
      new Point(tag.getCornerX(0), tag.getCornerY(0))
      , new Scalar(255, 255, 255), 5);


    Imgproc.circle(mat, 
    new Point(tag.getCenterX(), tag.getCenterY())//Circle the center point
    , 6, color);

    Imgproc.putText(mat, "ID: "+String.valueOf(tag.getId()), 
    new Point(tag.getCornerX(2), tag.getCornerY(2)) //Place text by one of the corners with ID
    , Imgproc.FONT_HERSHEY_SIMPLEX, 2,
           color, 7);
  }



  /**
   * This function is called every 20 ms, no matter the mode. Use this for items like diagnostics
   * that you want ran during disabled, autonomous, teleoperated and test.
   *
   * <p>This runs after the mode specific periodic functions, but before LiveWindow and
   * SmartDashboard integrated updating.
   */
  @Override
  public void robotPeriodic() {}

  /**
   * This autonomous (along with the chooser code above) shows how to select between different
   * autonomous modes using the dashboard. The sendable chooser code works with the Java
   * SmartDashboard. If you prefer the LabVIEW Dashboard, remove all of the chooser code and
   * uncomment the getString line to get the auto name from the text box below the Gyro
   *
   * <p>You can add additional auto modes by adding additional comparisons to the switch structure
   * below with additional strings. If using the SendableChooser make sure to add them to the
   * chooser code above as well.
   */
  @Override
  public void autonomousInit() {
    m_autoSelected = m_chooser.getSelected();
    // m_autoSelected = SmartDashboard.getString("Auto Selector", kDefaultAuto);
    System.out.println("Auto selected: " + m_autoSelected);
  }

  /** This function is called periodically during autonomous. */
  @Override
  public void autonomousPeriodic() {
    switch (m_autoSelected) {
      case kCustomAuto:
        // Put custom auto code here
        break;
      case kDefaultAuto:
      default:
        // Put default auto code here
        break;
    }
  }

  /** This function is called once when teleop is enabled. */
  @Override
  public void teleopInit() {}

  /** This function is called periodically during operator control. */
  @Override
  public void teleopPeriodic() {
/* 
    //I didn't write these comment below 💀
    double y = xboxController.getLeftY(); // Remember, this is reversed!
    double x = xboxController.getLeftX() * 1.1; // Counteract imperfect strafing
    double rx = xboxController.getRightX();

    // Denominator is the largest motor power (absolute value) or 1
    // This ensures all the powers maintain the same ratio, but only when
    // at least one is out of the range [-1, 1]
    double denominator = Math.max(Math.abs(y) + Math.abs(x) + Math.abs(rx), 1);
    double frontLeftPower = (y + x + rx) / denominator;
    double backLeftPower = (y - x + rx) / denominator;
    double frontRightPower = (y - x - rx) / denominator;
    double backRightPower = (y + x - rx) / denominator;

    frontLeft.set(frontLeftPower);
    backLeft.set(backLeftPower);
    frontRight.set(frontRightPower);
    backRight.set(backRightPower);
    */
  }

  /** This function is called once when the robot is disabled. */
  @Override
  public void disabledInit() {}

  /** This function is called periodically when disabled. */
  @Override
  public void disabledPeriodic() {}

  /** This function is called once when test mode is enabled. */
  @Override
  public void testInit() {}

  /** This function is called periodically during test mode. */
  @Override
  public void testPeriodic() {}

  /** This function is called once when the robot is first started up. */
  @Override
  public void simulationInit() {}

  /** This function is called periodically whilst in simulation. */
  @Override
  public void simulationPeriodic() {}
}
